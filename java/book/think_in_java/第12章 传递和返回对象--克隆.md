第12章 传递和返回对象

对象的“传递”有了一个较为深刻的认识，记住实际传递的只是一个句柄

12.1.1 别名问题
“别名”意味着多个句柄都试图指向同一个对象

所以倘若创建一个会修改自己参数的方法，必须向用户明确地指出这一情况，并警告使用那个方法可能会有的后果以及它的潜在威胁。由于存在这些混淆和缺陷，所以应该尽量避免改变参数。
若需在一个方法调用期间修改一个参数，且不打算修改外部参数，就应在自己的方法内部制作一个副本，从而保护那个参数。本章的大多数内容都是围绕这个问题展开的。

Java中的所有自变量或参数传递都是通过传递句柄进行的。

12.2.2 克隆对象
若需修改一个对象，同时不想改变调用者的对象，就要制作该对象的一个本地副本。
只需简单地使用clone()方法即可。Clone是“克隆”的意思，即制作完全一模一样的副本。
Vector v2 = (Vector)v.clone();

它只复制了一个对象的“表面”部分,重新造型为正确类型

12.2.3 使类具有克隆能力
尽管克隆方法是在所有类最基本的Object中定义的，但克隆仍然不会在每个类里自动进行。

1. 使用protected时的技巧
克隆时要注意的两个关键问题是：几乎肯定要调用super.clone()，以及注意将克隆设为public。

2. 实现Cloneable接口

public Object clone() {
	 Object o = null;
	 try {
	   o = super.clone();
	 } catch (CloneNotSupportedException e) {
	   System.out.println("MyObject can't clone");
	 }
	 return o;
}

Object.clone()会检查原先的对象有多大，再为新对象腾出足够多的内存，将所有二进制位从原来的对象复制到新对象。这叫作“按位复制”，


12.2.6 克隆合成对象

Vector进行深层复制的先决条件：在克隆了Vector后，必须在其中遍历，并克隆由Vector指向的每个对象。为了对Hashtable（散列表）进行深层复制，也必须采取类似的处理。

12.2.8 通过序列化进行深层复制
比深度克隆花更多的时间 


12.2.9 使克隆具有更大的深度
若新建一个类，它的基础类会默认为Object，并默认为不具备克隆能力（就象在下一节会看到的那样）。只要不明确地添加克隆能力，这种能力便不会自动产生。但我们可以在任何层添加它，然后便可从那个层开始向下具有克隆能力。

12.2.10 为什么有这个奇怪的设计

12.3 克隆的控制
(1) 保持中立，不为克隆做任何事情。也就是说，尽管不可对我们的类克隆，但从它继承的一个类却可根据实际情况决定克隆。只有Object.clone()要对类中的字段进行某些合理的操作时，才可以作这方面的决定。
class IsCloneable extends Ordinary 
 implements Cloneable {
	public Object clone() 
	   throws CloneNotSupportedException {
		return super.clone();
	}
}
(2) 支持clone()，采用实现Cloneable（可克隆）能力的标准操作，并覆盖clone()。在被覆盖的clone()中，可调用super.clone()，并捕获所有违例（这样可使clone()不“掷”出任何违例）。
//Cloneable:
class WrongClone extends Ordinary {
	public Object clone()
	   throws CloneNotSupportedException {
	 return super.clone(); // Throws exception
	}
}
(3) 有条件地支持克隆。若类容纳了其他对象的句柄，而那些对象也许能够克隆（集合类便是这样的一个例子），就可试着克隆拥有对方句柄的所有对象；如果它们“掷”出了违例，只需让这些违例通过即可。举个例子来说，假设有一个特殊的Vector，它试图克隆自己容纳的所有对象。编写这样的一个Vector时，并不知道客户程序员会把什么形式的对象置入这个Vector中，所以并不知道它们是否真的能够克隆。
(4) 不实现Cloneable()，但是将clone()覆盖成protected，使任何字段都具有正确的复制行为。这样一来，从这个类继承的所有东西都能覆盖clone()，并调用super.clone()来产生正确的复制行为。注意在我们实现方案里，可以而且应该调用super.clone()——即使那个方法本来预期的是一个Cloneable对象（否则会掷出一个违例），因为没有人会在我们这种类型的对象上直接调用它。它只有通过一个衍生类调用；对那个衍生类来说，如果要保证它正常工作，需实现Cloneable。
(5) 不实现Cloneable来试着防止克隆，并覆盖clone()，以产生一个违例。为使这一设想顺利实现，只有令从它衍生出来的任何类都调用重新定义后的clone()里的suepr.clone()。
(6) 将类设为final，从而防止克隆。若clone()尚未被我们的任何一个上级类覆盖，这一设想便不会成功。若已被覆盖，那么再一次覆盖它，并“掷”出一个CloneNotSupportedException（克隆不支持）违例。为担保克隆被禁止，将类设为final是唯一的办法。除此以外，一旦涉及保密对象或者遇到想对创建的对象数量进行控制的其他情况，应该将所有构建器都设为private，并提供一个或更多的特殊方法来创建对象。采用这种方式，这些方法就可以限制创建的对象数量以及它们的创建条件——一种特殊情况是第16章要介绍的singleton（独子）方案。

总之，如果希望一个类能够克隆，那么：
(1) 实现Cloneable接口
(2) 覆盖clone()
(3) 在自己的clone()中调用super.clone()
(4) 在自己的clone()中捕获违例
这一系列步骤能达到最理想的效果。





